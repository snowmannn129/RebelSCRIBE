# GenerateGeometry

**API Version:** 1.0.0

**Component:** RebelCAD

Evaluate curve derivative at parameter value

// Find knot span
        int span = basis->FindSpan(t);
        if (span < 0) {
            return {};
        }

        // Get basis function derivatives
        auto ders = basis->EvaluateDerivatives(t, span, order);
        if (ders.empty()) {
            return {};
        }

        std::vector<glm::vec3> derivatives(order + 1);
        if (!params.rational) {
            // Non-rational case
            for (int k = 0; k <= order; ++k) {
                derivatives[k] = glm::vec3(0.0f);
                for (size_t i = 0; i < ders[k].size(); ++i) {
                    size_t idx = span - params.degree + i;
                    if (idx >= control_points.size()) {
                        continue;
                    }
                    derivatives[k] += control_points[idx] * ders[k][i];
                }
            }
        } else {
            // Rational case - use quotient rule
            std::vector<glm::vec3> A(order + 1, glm::vec3(0.0f));
            std::vector<float> w(order + 1, 0.0f);

            // Calculate weighted sum for each derivative
            for (int k = 0; k <= order; ++k) {
                for (size_t i = 0; i < ders[k].size(); ++i) {
                    size_t idx = span - params.degree + i;
                    if (idx >= control_points.size()) {
                        continue;
                    }
                    A[k] += control_points[idx] * weights[idx] * ders[k][i];
                    w[k] += weights[idx] * ders[k][i];
                }
            }

            // Apply quotient rule
            float w0 = w[0];
            if (std::abs(w0) > params.tolerance) {
                derivatives[0] = A[0] / w0;
                for (int k = 1; k <= order; ++k) {
                    glm::vec3 v = A[k];
                    for (int i = 1; i <= k; ++i) {
                        float bin = static_cast<float>(BinomialCoefficient(k, i));
                        v -= derivatives[k-i] * (w[i] * bin);
                    }
                    derivatives[k] = v / w0;
                }
            }
        }

        return derivatives;
    }

    /**

## Parameters

- **t**: Parameter value
- **order**: Derivative order
- **segments**: Number of segments

## Returns

: Derivative vectors
/
    std::vector<glm::vec3> EvaluateDerivatives(float t, int order) const {
        if (!is_configured || control_points.empty() || order < 1) {
            return {};
        }

        // Find knot span
        int span = basis->FindSpan(t);
        if (span < 0) {
            return {};
        }

        // Get basis function derivatives
        auto ders = basis->EvaluateDerivatives(t, span, order);
        if (ders.empty()) {
            return {};
        }

        std::vector<glm::vec3> derivatives(order + 1);
        if (!params.rational) {
            // Non-rational case
            for (int k = 0; k <= order; ++k) {
                derivatives[k] = glm::vec3(0.0f);
                for (size_t i = 0; i < ders[k].size(); ++i) {
                    size_t idx = span - params.degree + i;
                    if (idx >= control_points.size()) {
                        continue;
                    }
                    derivatives[k] += control_points[idx] * ders[k][i];
                }
            }
        } else {
            // Rational case - use quotient rule
            std::vector<glm::vec3> A(order + 1, glm::vec3(0.0f));
            std::vector<float> w(order + 1, 0.0f);

            // Calculate weighted sum for each derivative
            for (int k = 0; k <= order; ++k) {
                for (size_t i = 0; i < ders[k].size(); ++i) {
                    size_t idx = span - params.degree + i;
                    if (idx >= control_points.size()) {
                        continue;
                    }
                    A[k] += control_points[idx] * weights[idx] * ders[k][i];
                    w[k] += weights[idx] * ders[k][i];
                }
            }

            // Apply quotient rule
            float w0 = w[0];
            if (std::abs(w0) > params.tolerance) {
                derivatives[0] = A[0] / w0;
                for (int k = 1; k <= order; ++k) {
                    glm::vec3 v = A[k];
                    for (int i = 1; i <= k; ++i) {
                        float bin = static_cast<float>(BinomialCoefficient(k, i));
                        v -= derivatives[k-i] * (w[i] * bin);
                    }
                    derivatives[k] = v / w0;
                }
            }
        }

        return derivatives;
    }

    /**

