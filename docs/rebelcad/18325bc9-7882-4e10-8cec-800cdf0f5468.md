# updateTransform

**API Version:** 1.0.0

**Component:** RebelCAD

Finds closest point on geometry to given point

// Clamp point to AABB bounds
        glm::vec3 closest = glm::clamp(localPoint, m_aabb.min, m_aabb.max);

        // Calculate normal
        glm::vec3 normal(0.0f);
        if (localPoint.x < m_aabb.min.x) normal.x = -1.0f;
        else if (localPoint.x > m_aabb.max.x) normal.x = 1.0f;
        if (localPoint.y < m_aabb.min.y) normal.y = -1.0f;
        else if (localPoint.y > m_aabb.max.y) normal.y = 1.0f;
        if (localPoint.z < m_aabb.min.z) normal.z = -1.0f;
        else if (localPoint.z > m_aabb.max.z) normal.z = 1.0f;
        normal = glm::normalize(normal);

        // Transform back to world space
        closest = glm::vec3(m_worldTransform * glm::vec4(closest, 1.0f));
        normal = glm::normalize(glm::vec3(m_worldTransform * glm::vec4(normal, 0.0f)));

        return {closest, normal};
    }

    /**

## Parameters

- **point**: Point to test against
- **transform**: New world transform matrix

## Returns

: Pair of closest point and surface normal
/
    std::pair<glm::vec3, glm::vec3> findClosestPoint(
        const glm::vec3& point) const override {
        
        // Transform point to local space
        glm::mat4 invTransform = glm::inverse(m_worldTransform);
        glm::vec3 localPoint = glm::vec3(invTransform * glm::vec4(point, 1.0f));

        // Clamp point to AABB bounds
        glm::vec3 closest = glm::clamp(localPoint, m_aabb.min, m_aabb.max);

        // Calculate normal
        glm::vec3 normal(0.0f);
        if (localPoint.x < m_aabb.min.x) normal.x = -1.0f;
        else if (localPoint.x > m_aabb.max.x) normal.x = 1.0f;
        if (localPoint.y < m_aabb.min.y) normal.y = -1.0f;
        else if (localPoint.y > m_aabb.max.y) normal.y = 1.0f;
        if (localPoint.z < m_aabb.min.z) normal.z = -1.0f;
        else if (localPoint.z > m_aabb.max.z) normal.z = 1.0f;
        normal = glm::normalize(normal);

        // Transform back to world space
        closest = glm::vec3(m_worldTransform * glm::vec4(closest, 1.0f));
        normal = glm::normalize(glm::vec3(m_worldTransform * glm::vec4(normal, 0.0f)));

        return {closest, normal};
    }

    /**

