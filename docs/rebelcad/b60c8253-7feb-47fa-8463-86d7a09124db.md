# FindSpan

**API Version:** 1.0.0

**Component:** RebelCAD

Calculate basis functions at parameter value

// Calculate basis functions
        std::vector<float> values(degree + 1, 0.0f);
        std::vector<float> left(degree + 1);
        std::vector<float> right(degree + 1);

        // Initialize degree 0
        values[0] = 1.0f;

        // Calculate up to requested degree
        for (int j = 1; j <= degree; ++j) {
            left[j] = t - knots[span + 1 - j];
            right[j] = knots[span + j] - t;
            float saved = 0.0f;

            for (int r = 0; r < j; ++r) {
                float temp = values[r] / (right[r + 1] + left[j - r]);
                values[r] = saved + right[r + 1] * temp;
                saved = left[j - r] * temp;
            }

            values[j] = saved;
        }

        // Cache result
        cache.push_back({t, span, values, {}});
        if (cache.size() > 100) { // Limit cache size
            cache.erase(cache.begin());
        }

        return values;
    }

    /**

## Parameters

- **t**: Parameter value
- **span**: Knot span containing t
- **order**: Maximum derivative order

## Returns

: Vector of basis function values
/
    std::vector<float> Evaluate(float t, int span) const {
        // Check cache first
        for (const auto& entry : cache) {
            if (std::abs(entry.t - t) <= 1e-6f && entry.span == span) {
                return entry.values;
            }
        }

        // Calculate basis functions
        std::vector<float> values(degree + 1, 0.0f);
        std::vector<float> left(degree + 1);
        std::vector<float> right(degree + 1);

        // Initialize degree 0
        values[0] = 1.0f;

        // Calculate up to requested degree
        for (int j = 1; j <= degree; ++j) {
            left[j] = t - knots[span + 1 - j];
            right[j] = knots[span + j] - t;
            float saved = 0.0f;

            for (int r = 0; r < j; ++r) {
                float temp = values[r] / (right[r + 1] + left[j - r]);
                values[r] = saved + right[r + 1] * temp;
                saved = left[j - r] * temp;
            }

            values[j] = saved;
        }

        // Cache result
        cache.push_back({t, span, values, {}});
        if (cache.size() > 100) { // Limit cache size
            cache.erase(cache.begin());
        }

        return values;
    }

    /**

